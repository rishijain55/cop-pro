#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <SDL2/SDL_image.h>
#include <stdio.h>
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <SDL2/SDL_mixer.h>
#include<deque>
#include<utility>
#include<thread>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#define PORT 8080
#include <arpa/inet.h>

using namespace std;

// Screen dimension constants
const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;

const int LEVEL_WIDTH = 8400;
const int LEVEL_HEIGHT = 4800;

int tile[80][140] = {
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};
// int tile[80][140]={};
int temp[80][140] = {0};

// The music that will be played
Mix_Music *gMusic = NULL;

// The sound effects that will be used
Mix_Chunk *grun = NULL;
Mix_Chunk *gyulu = NULL;

int pickupX[] = {1020, 1380, 1140, 3420, 2820};
int pickupY[] = {720, 540, 2790, 420, 2940};
int dropX[] = {7440, 7200, 5400, 6060, 4920};
int dropY[] = {360, 1380, 2730, 1080, 1380};
string dropArea[] = {"Himadri", "LHC", "Hockey Ground", "Library", "SIT"};
//  SDL_Color white ={255,255,255,255};
// Texture wrapper class
class LTexture
{
public:
	// Initializes variables
	LTexture();

	// Deallocates memory
	~LTexture();

	// Loads image at specified path
	bool loadFromFile(std::string path);

#if defined(SDL_TTF_MAJOR_VERSION)
	// Creates image from font string
	bool loadFromRenderedText(std::string textureText, SDL_Color textColor);
#endif

	// Deallocates texture
	void free();

	void set(int w, int h);
	// Set color modulation
	void setColor(Uint8 red, Uint8 green, Uint8 blue);

	// Set blending
	void setBlendMode(SDL_BlendMode blending);

	// Set alpha modulation
	void setAlpha(Uint8 alpha);

	// Renders texture at given point
	void render(int x, int y, SDL_Rect *clip = NULL, double angle = 0.0, SDL_Point *center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE);

	// Gets image dimensions
	int getWidth();
	int getHeight();

	// LTexture(const LTexture &p1) {mTexture = p1.mTexture; mWidth = p1.mWidth;mHeight = p1.mHeight; }

private:
	// The actual hardware texture
	SDL_Texture *mTexture;

	// Image dimensions
	int mWidth;
	int mHeight;
};

class LWindow
{
public:
	// Intializes internals
	LWindow();

	// Creates window
	bool init();

	// Creates renderer from internal window
	SDL_Renderer *createRenderer();

	// Handles window events
	void handleEvent(SDL_Event &e);

	// Deallocates internals
	void free();

	// Window dimensions
	int getWidth();
	int getHeight();

	// Window focii
	bool hasMouseFocus();
	bool hasKeyboardFocus();
	bool isMinimized();

private:
	// Window data
	SDL_Window *mWindow;

	// Window dimensions
	int mWidth;
	int mHeight;

	// Window focus
	bool mMouseFocus;
	bool mKeyboardFocus;
	bool mFullScreen;
	bool mMinimized;
};

class Player
{
public:
	// The dimensions of the dot
	int PLAYER_WIDTH = 30;
	int PLAYER_HEIGHT = 60;
	int frame = 2;
	int dir = -1;
	bool wasPlayerMoving = false;

	// Maximum axis velocity of the dot
	static const int PLAYER_VEL = 15;

	// Initializes the variables
	Player();

	// Takes key presses and adjusts the dot's velocity
	void handleEvent();
	bool handleEventSingle(SDL_Event &e);

	void set(int w, int h);

	// Moves the dot
	void move(int camX, int camY);
	void changePos(int x, int y);
	void changeFrame(int dir);
	// Position accessors
	int getPosX();
	int getPosY();
	// Shows the dot on the screen
	void render(int camX, int camY, SDL_Rect *clip = NULL);
	void reset();
	bool collided();

private:
	// The X and Y offsets of the dot
	int mPosX, mPosY;
	// The velocity of the dot
	int mVelX, mVelY;
};

// The application time based timer
class LTimer
{
public:
	// Initializes variables
	LTimer();

	// The various clock actions
	void start();
	void stop();
	void pause();
	void unpause();

	// Gets the timer's time
	Uint32 getTicks();

	// Checks the status of the timer
	bool isStarted();
	bool isPaused();

private:
	// The clock time when the timer started
	Uint32 mStartTicks;

	// The ticks stored when the timer was paused
	Uint32 mPausedTicks;

	// The timer status
	bool mPaused;
	bool mStarted;
};

class Yulu
{
public:
	// The dimensions of the dot
	int YULU_WIDTH = 60;
	int YULU_HEIGHT = 60;
	int frame = 1;
	int dir = -1;
	bool wasYuluMoving = false;
	// Maximum axis velocity of the dot
	static const int YULU_VEL = 30;

	// Initializes the variables
	Yulu();

	// Takes key presses and adjusts the dot's velocity
	void handleEvent();
	bool handleEventSingle(SDL_Event &e);
	void changeFrame(int dir);
	void set(int w, int h);
	void changePos(int x, int y);
	// Moves the dot
	void move(int camX, int camY);
	// Position accessors
	int getPosX();
	int getPosY();
	// Shows the dot on the screen
	void render(int camX, int camY, SDL_Rect *clip = NULL);
	void reset();
	bool collided();

private:
	// The X and Y offsets of the dot
	int mPosX, mPosY;
	// The velocity of the dot
	int mVelX, mVelY;
};

class Professor
{
public:
	int frame = 2;
	// The dimensions of the dot
	int PROFESSOR_WIDTH = 30;
	int PROFESSOR_HEIGHT = 60;

	// Maximum axis velocity of the dot
	static const int PROFESSOR_VEL = 30;

	// Initializes the variables
	Professor();

	void set(int w, int h);
	void changePos(int x, int y);
	void changeFrame(int dir);
	// Moves the dot
	void move();
	// Position accessors
	int getPosX();
	int getPosY();
	// Shows the dot on the screen
	void render(int camX, int camY, SDL_Rect *clip = NULL);
	void reset();
	bool collided();

private:
	// The X and Y offsets of the dot
	int mPosX, mPosY;
	// The velocity of the dot
	int dir;
};
class Dog
{
public:
	// The dimensions of the dot
	int frame = 2;
	int DOG_WIDTH = 60;
	int DOG_HEIGHT = 60;

	// Maximum axis velocity of the dot
	static const int DOG_VEL = 30;

	// Initializes the variables
	Dog();

	void set(int w, int h);
	void changePos(int x, int y);
	void changeFrame(int dir);
	// Moves the dot
	void move();
	// Position accessors
	int getPosX();
	int getPosY();
	// Shows the dot on the screen
	void render(int camX, int camY, SDL_Rect *clip = NULL);
	void reset();
	bool collided();

private:
	// The X and Y offsets of the dot
	int mPosX, mPosY;
	// The velocity of the dot
	int dir;
};

class ScoreCard
{
public:
	int healthLimit = 100;
	int moneyLimit = 1000;
	int happinessLimit = 10;
	ScoreCard();
	void changeHealth(int offset);
	void changeMoney(int offset);
	void changeHappiness(int offset);
	void render();
	void reset();
	int health, money, happiness;
};

class LPackage
{
public:
	int pickupPosX, pickupPosY;
	int dropPosX, dropPosY;
	bool pickedUp;
	LPackage();
	void changePos(int px, int py, int dx, int dy);
	void render(int camX, int camY, SDL_Rect *clip = NULL);
	void pickup(string s);
	void drop();
	void handleEvent(SDL_Event &e);
};

// Starts up SDL and creates window
bool init();

// Loads media
bool loadMedia();

// Frees media and shuts down SDL
void close();

// Our custom window
// initializing textures and windows
LWindow gWindow;

// The window renderer
SDL_Renderer *gRenderer = NULL;

// Scene textures
LTexture gBackgroundStartScreenTexture;
LTexture gBackgroundPlayTexture;
LTexture gSpriteSheetTexture;
LTexture gYuluSheetTexture;
LTexture gYuluStandRectTexture;
LTexture gYuluStandSqTexture;
LTexture ghelpsectionbg;
LTexture drinkTexture;
LTexture foodTexture;
LTexture gProfessorTexture;
LTexture gDogTexture;
LTexture dogTextTexture;
LTexture profTextTexture;
Player player1;
Player player2;
Yulu yulu1;
Yulu yulu2;
Dog dog1;
LPackage package;
Professor professor1;
LTexture gPlayBefore;
LTexture gPlayHover;
LTexture gPlayDisplay;
LTexture quitText;
LTexture yuluText;
LTexture gHeartTexture;
LTexture gCoinTexture;
LTexture gPickupTexture;
LTexture gBoxTexture;
LTexture gDropTexture;
LTexture gHappinessTexture;
LTexture gMoneyTextTexture;
const int BOUNCING_FRAMES = 4;
SDL_Rect gBouncingManClips[ BOUNCING_FRAMES ];
LTexture gManTexture;
LTexture jumpGameTexture;
LTexture gBoxDinoTexture;
LTexture gTreeTexture;
ScoreCard playerScore;
LTimer frameTime;
int yuluMoneyFrame=0;
int yuluMoneyFrameLimit =30;
int mapTileSize = 60;
int xNoSquares = 140;
int yNoSquares = 80;
int playerHoldMoveSpeed = 2;
int yuluHoldMoveSpeed = 6;
int play = 2;
int professorFrame = 0;
int DogFrame = 0;
int countFrame = 0;
int YuluFrame = 0;
int pickupDestiny = 0;
bool onYulu1 = false;
bool onYulu2 = false;
int dinoCoinGain=0;
SDL_Color white = {255, 255, 255, 255};

const int WALKING_ANIMATION_FRAMES = 8;
SDL_Rect gSpriteClips[WALKING_ANIMATION_FRAMES];

const int YULU_ANIMATION_FRAMES = 4;
SDL_Rect gYuluClips[YULU_ANIMATION_FRAMES];

const int DOG_ANIMATION_FRAMES = 8;
SDL_Rect gDogClips[DOG_ANIMATION_FRAMES];

TTF_Font *gFont = NULL;

void drawTexture(int x, int y, int w, int h, int r, int g, int b, int opak)
{
	SDL_Rect fillRect = {x, y, w, h};
	SDL_SetRenderDrawColor(gRenderer, r, g, b, opak);
	SDL_SetRenderDrawBlendMode(gRenderer, SDL_BLENDMODE_BLEND);
	SDL_RenderFillRect(gRenderer, &fillRect);
}
void drawBorder(int x, int y, int w, int h, int thickness, int r, int g, int b, int opak)
{
	drawTexture(x - thickness, y - thickness, w + 2 * thickness, thickness, r, g, b, opak);
	drawTexture(x - thickness, y - thickness, thickness, h + 2 * thickness, r, g, b, opak);
	drawTexture(x + w, y - thickness, thickness, h + 2 * thickness, r, g, b, opak);
	drawTexture(x - thickness, y + h, w + 2 * thickness, thickness, r, g, b, opak);
}

int mapElement(int posX, int posY)
{
	int x = posX / mapTileSize;
	int y = posY / mapTileSize;
	return y * xNoSquares + x;
}

bool wallCollision(int x, int y)
{
	int tileNo = mapElement(x, y);
	int tileCol = tileNo % xNoSquares;
	int tileRow = tileNo / xNoSquares;

	return tile[tileRow][tileCol] == 0;
}

LPackage::LPackage()
{
	pickedUp = false;
	pickupPosX = 0;
	pickupPosY = 0;
	dropPosX = 0;
	dropPosY = 0;
}
void LPackage::changePos(int px, int py, int dx, int dy)
{
	pickupPosX = px;
	pickupPosY = py;
	dropPosX = dx;
	dropPosY = dy;
}

void LPackage::render(int camX, int camY, SDL_Rect *clip)
{
	if (!pickedUp)
	{
		gBoxTexture.set(30, 30);
		gBoxTexture.render(pickupPosX - camX, pickupPosY - camY, clip);
	}
	else
	{
		drawTexture(dropPosX - camX, dropPosY - camY, mapTileSize / 2, mapTileSize / 2, 255, 255, 255, 255);
	}
}
void LPackage ::pickup(string s)
{

	// SDL_Color white = {255, 255, 255, 255};
	if (!pickedUp)
	{
		if (player1.getPosX() >= pickupPosX - mapTileSize / 2 && player1.getPosX() < pickupPosX + mapTileSize && player1.getPosY() >= pickupPosY - mapTileSize / 2 && player1.getPosY() < pickupPosY + mapTileSize)
		{

			cout << "inreach" << endl;
			gPickupTexture.loadFromRenderedText("Pick the box using RSHIFT. Deliver at " + s, white);
			gPickupTexture.render((gWindow.getWidth() - gPickupTexture.getWidth()) / 2, (gWindow.getHeight() - gPickupTexture.getHeight() * 4));
		}
	}
}
void LPackage ::drop()
{

	if (pickedUp)
	{
		if (player1.getPosX() >= dropPosX - mapTileSize / 2 && player1.getPosX() < dropPosX + mapTileSize && player1.getPosY() >= dropPosY - mapTileSize / 2 && player1.getPosY() < dropPosY + mapTileSize)
		{

			cout << "inreach" << endl;

			gDropTexture.loadFromRenderedText("Drop the box using RSHIFT ", white);
			gDropTexture.render((gWindow.getWidth() - gDropTexture.getWidth()) / 2, (gWindow.getHeight() - gDropTexture.getHeight() * 2));
		}
	}
}

void LPackage ::handleEvent(SDL_Event &e)
{
	if (!pickedUp)
	{
		if (player1.getPosX() >= pickupPosX - mapTileSize / 2 && player1.getPosX() < pickupPosX + mapTileSize && player1.getPosY() >= pickupPosY - mapTileSize / 2 && player1.getPosY() < pickupPosY + mapTileSize)
		{
			if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_RSHIFT)
			{
				pickedUp = true;
			}
		}
	}
	else
	{
		if (player1.getPosX() >= dropPosX - mapTileSize / 2 && player1.getPosX() < dropPosX + mapTileSize && player1.getPosY() >= dropPosY - mapTileSize / 2 && player1.getPosY() < dropPosY + mapTileSize)
		{
			if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_RSHIFT)
			{
				pickedUp = false;
				playerScore.changeMoney(20);
				pickupDestiny = (pickupDestiny + 1) % 5;
			}
		}
	}
}

ScoreCard ::ScoreCard()
{
	money = 100;
	happiness = 5;
	health = 100;
}
void ScoreCard ::reset()
{
	money = 100;
	happiness = 5;
	health = 100;
}
void ScoreCard::changeHealth(int offset)
{
	health += offset;
	if (health >= healthLimit)
	{
		health = healthLimit;
	}
	else if (health < 0)
	{
		health = 0;
	}
}
void ScoreCard::changeMoney(int offset)
{
	money += offset;
	if (money >= moneyLimit)
	{
		money = moneyLimit;
	}
}
void ScoreCard::changeHappiness(int offset)
{
	happiness += offset;
	if (happiness >= happinessLimit)
	{
		happiness = happinessLimit;
	}
	else if (happiness < 0)
	{
		happiness = 0;
	}
}
SDL_Color gold = {255, 215, 0, 255};
void ScoreCard ::render()
{
	// drawTexture(0,0,gWindow.getWidth()/10,gWindow.getHeight()/10,0,255,255,200);
	gHappinessTexture.set(30, 30);
	gHeartTexture.set(30, 30);
	gCoinTexture.set(30, 30);
	
	string moneyString = to_string(money);
	int thickness = 3;
	float healthWidth = 200 * ((health * 1.0) / healthLimit);
	float moneyWidth = 200 * ((money * 1.0) / moneyLimit);
	float happinessWidth = 200 * ((happiness * 1.0) / happinessLimit);
	drawTexture(45, 5, healthWidth, 20, 255, 0, 0, 255);
	drawBorder(45, 5, 200, 20, thickness, 255, 255, 255, 255);
	gMoneyTextTexture.loadFromRenderedText(moneyString, gold);
	float textHeight = 30;
	float textWidth = textHeight * (gMoneyTextTexture.getWidth() / (1.0 * gMoneyTextTexture.getHeight()));
	gMoneyTextTexture.set(textWidth, textHeight);
	// drawTexture(45,45,moneyWidth,20,255,215,0,255);

	// drawBorder(45,45,200,20,thickness,255,255,255,255);
	drawTexture(45, 45, happinessWidth, 20, 255, 182, 193, 255);
	drawBorder(45, 45, 200, 20, thickness, 255, 255, 255, 255);
	gHeartTexture.render(5, 0);
	gCoinTexture.render(5, 80);
	
	gHappinessTexture.render(5, 40);
	gMoneyTextTexture.render(45, 80);
}
Player::Player()
{
	// Initialize the offsets
	mPosX = 0;
	mPosY = 0;

	// Initialize the velocity
	mVelX = 0;
	mVelY = 0;
	frame = 4;
	dir = -1;
}
void Player::reset()
{

	// Initialize the offsets
	mPosX = 0;
	mPosY = 0;

	// Initialize the velocity
	mVelX = 0;
	mVelY = 0;
	frame = 4;
	dir = -1;
}
void Player::changePos(int x, int y)
{

	// Initialize the offsets
	mPosX = x;
	mPosY = y;
}

void Player::changeFrame(int dir)
{

	if (dir == 0)
	{
		if (frame == 0)
		{
			frame = 1;
		}
		else
		{
			frame = 0;
		}
	}
	else if (dir == 1)
	{
		if (frame == 2)
		{
			frame = 3;
		}
		else
		{
			frame = 2;
		}
	}
	else if (dir == 2)
	{
		if (frame == 4)
		{
			frame = 5;
		}
		else
		{
			frame = 4;
		}
	}
	else if (dir == 3)
	{
		if (frame == 6)
		{
			frame = 7;
		}
		else
		{
			frame = 6;
		}
	}
	else
	{
	}
}

void Player::handleEvent()
{
	// If a key was pressed
	SDL_PumpEvents();
	const Uint8 *keystates = SDL_GetKeyboardState(NULL);
	if (keystates[SDL_SCANCODE_LEFT] && countFrame == 0)
	{
		changeFrame(3);

		mVelX -= PLAYER_VEL;
		// cout<<"player moved"<<endl;
	}
	else
	{
		//  countFrame= (countFrame+1)%playerHoldMoveSpeed;
	}
	if (keystates[SDL_SCANCODE_RIGHT] && countFrame == 0)
	{
		changeFrame(1);

		mVelX += PLAYER_VEL;
	}
	else
	{
		//  countFrame= (countFrame+1)%playerHoldMoveSpeed;
	}
	// if( e.type == SDL_KEYDOWN )
	if (keystates[SDL_SCANCODE_UP] && countFrame == 0)
	{
		changeFrame(0);
		mVelY -= PLAYER_VEL;
	}
	else
	{
		//  countFrame= (countFrame+1)%playerHoldMoveSpeed;
	}
	if (keystates[SDL_SCANCODE_DOWN] && countFrame == 0)
	{
		changeFrame(2);

		mVelY += PLAYER_VEL;
	}
	else
	{
		//  countFrame= (countFrame+1)%playerHoldMoveSpeed;
	}
	if (!keystates[SDL_SCANCODE_DOWN] && !keystates[SDL_SCANCODE_UP] && !keystates[SDL_SCANCODE_RIGHT] && !keystates[SDL_SCANCODE_LEFT])
	{
		countFrame = 0;
	}
	cout << countFrame << endl;
	countFrame = (countFrame + 1) % playerHoldMoveSpeed;
}

bool Player::handleEventSingle(SDL_Event &e)
{
	// If a key was pressed
	bool oneTimePress = false;
	if (e.type == SDL_KEYDOWN && e.key.repeat == 0)
	{

		// Adjust the velocity
		switch (e.key.keysym.sym)
		{

		case SDLK_UP:

			changeFrame(0);
			mVelY -= PLAYER_VEL;
			Mix_PlayChannel(-1, grun, 0);
			countFrame = (countFrame + 1) % playerHoldMoveSpeed;
			oneTimePress = true;
			// cout<<"player moved"<<endl;

			break;
		case SDLK_DOWN:

			changeFrame(2);
			mVelY += PLAYER_VEL;
			Mix_PlayChannel(-1, grun, 0);
			countFrame = (countFrame + 1) % playerHoldMoveSpeed;
			oneTimePress = true;
			// cout<<"player moved"<<endl;

			break;
		case SDLK_LEFT:

			changeFrame(3);
			oneTimePress = true;
			mVelX -= PLAYER_VEL;
			Mix_PlayChannel(-1, grun, 0);
			countFrame = (countFrame + 1) % playerHoldMoveSpeed;
			// cout<<"player moved"<<endl;

			break;
		case SDLK_RIGHT:

			changeFrame(1);

			mVelX += PLAYER_VEL;
			Mix_PlayChannel(-1, grun, 0);
			countFrame = (countFrame + 1) % playerHoldMoveSpeed;
			oneTimePress = true;

			break;
		}
	}
	return oneTimePress;
}
void Player ::set(int w, int h)
{
	PLAYER_WIDTH = w;
	PLAYER_HEIGHT = h;
}
void Player::move(int camX, int camY)
{

	// Move the dot left or right
	mPosX += mVelX;

	// If the dot went too far to the left or right
	if ((mPosX < 0) || (mPosX + PLAYER_WIDTH - camX > gWindow.getWidth()))
	{
		// Move back
		mPosX -= mVelX;
	}

	// Move the dot up or down
	mPosY += mVelY;

	// If the dot went too far up or down
	if ((mPosY < 0) || (mPosY + PLAYER_HEIGHT - camY > gWindow.getHeight()))
	{
		// Move back
		mPosY -= mVelY;
	}
	if (collided())
	{
		mPosX -= mVelX;
		mPosY -= mVelY;
	}
	mVelX = 0;
	mVelY = 0;
}
void Player::render(int camX, int camY, SDL_Rect *clip)
{
	// Show the dot relative to the camera
	gSpriteSheetTexture.render(mPosX - camX, mPosY - camY, clip);
}

int Player ::getPosX()
{
	return mPosX;
}
int Player ::getPosY()
{
	return mPosY;
}

bool Player ::collided()
{
	bool collided = false;
	// collided = collided||wallCollision(mPosX,mPosY);
	collided = collided || (wallCollision(mPosX, mPosY + 45));
	collided = collided || (wallCollision(mPosX+15, mPosY + 45));
	// collided = collided||(wallCollision(mPosX+PLAYER_WIDTH,mPosY)&&(mPosX%mapTileSize==0));
	// collided = collided || (wallCollision(mPosX + PLAYER_WIDTH, mPosY + PLAYER_HEIGHT / 2) && (mPosY % (mapTileSize / 2) == 0) && (mPosX % (mapTileSize / 2) != 0));
	// collided = collided || (wallCollision(mPosX, mPosY + PLAYER_HEIGHT) && (mPosY % (mapTileSize / 2) != 0));
	// collided = collided || (wallCollision(mPosX + PLAYER_WIDTH, mPosY + PLAYER_HEIGHT) && (mPosY % (mapTileSize / 2) != 0));
	return collided;
}

Professor::Professor()
{

	// Initialize the offsets
	mPosX = 5940;
	mPosY = 1020;

	// Initialize the velocity
	dir = 1;
	frame = 4;
}

void Professor::reset()
{

	// Initialize the offsets
	mPosX = 5940;
	mPosY = 1020;

	// Initialize the velocity
	dir = 1;
	frame = 4;
}
void Professor::changePos(int x, int y)
{

	// Initialize the offsets
	mPosX = x;
	mPosY = y;
}

void Professor ::set(int w, int h)
{
	PROFESSOR_WIDTH = w;
	PROFESSOR_HEIGHT = h;
}

void Professor ::changeFrame(int dir)
{

	if (dir == 0)
	{
		if (frame == 0)
		{
			frame = 1;
		}
		else
		{
			frame = 0;
		}
	}
	else if (dir == 1)
	{
		if (frame == 2)
		{
			frame = 3;
		}
		else
		{
			frame = 2;
		}
	}
	else if (dir == 2)
	{
		if (frame == 4)
		{
			frame = 5;
		}
		else
		{
			frame = 4;
		}
	}
	else if (dir == 3)
	{
		if (frame == 6)
		{
			frame = 7;
		}
		else
		{
			frame = 6;
		}
	}
	else
	{
	}
}

void Professor::move()
{
	if (dir == 0)
	{
		mPosY -= PROFESSOR_VEL;
		if (mPosY < 0 || mPosY + PROFESSOR_HEIGHT > LEVEL_HEIGHT || mPosX < 0 || mPosX + PROFESSOR_WIDTH > LEVEL_WIDTH)
		{
			mPosY += PROFESSOR_VEL;
			dir = 1;
		}
		else if (collided())
		{
			mPosY += PROFESSOR_VEL;
			dir = 1;
		}
	}
	else if (dir == 1)
	{
		mPosX += PROFESSOR_VEL;
		if (mPosY < 0 || mPosY + PROFESSOR_HEIGHT > LEVEL_HEIGHT || mPosX < 0 || mPosX + PROFESSOR_WIDTH > LEVEL_WIDTH)
		{
			mPosX -= PROFESSOR_VEL;
			dir = 2;
		}
		else if (collided())
		{
			mPosX -= PROFESSOR_VEL;
			dir = 2;
		}
	}
	else if (dir == 2)
	{
		mPosY += PROFESSOR_VEL;
		if (mPosY < 0 || mPosY + PROFESSOR_HEIGHT > LEVEL_HEIGHT || mPosX < 0 || mPosX + PROFESSOR_WIDTH > LEVEL_WIDTH)
		{
			mPosY -= PROFESSOR_VEL;
			dir = 3;
		}
		else if (collided())
		{
			mPosY -= PROFESSOR_VEL;
			dir = 3;
		}
	}
	else if (dir == 3)
	{
		mPosX -= PROFESSOR_VEL;
		if (mPosY < 0 || mPosY + PROFESSOR_HEIGHT > LEVEL_HEIGHT || mPosX < 0 || mPosX + PROFESSOR_WIDTH > LEVEL_WIDTH)
		{
			mPosX += PROFESSOR_VEL;
			dir = 0;
		}
		else if (collided())
		{
			mPosX += PROFESSOR_VEL;
			dir = 0;
		}
	}
}
void Professor::render(int camX, int camY, SDL_Rect *clip)
{
	// Show the dot relative to the camera
	gProfessorTexture.render(mPosX - camX, mPosY - camY, clip);
}

int Professor ::getPosX()
{
	return mPosX;
}
int Professor ::getPosY()
{
	return mPosY;
}

bool Professor ::collided()
{
	bool collided = false;
	// collided = collided||wallCollision(mPosX,mPosY);
	collided = collided || (wallCollision(mPosX, mPosY + PROFESSOR_HEIGHT / 2));
	return collided;
}
Dog::Dog()
{

	// Initialize the offsets
	mPosX = 2100;
	mPosY = 2190;

	// Initialize the velocity
	dir = 1;
	frame = 4;
}

void Dog::reset()
{

	// Initialize the offsets
	mPosX = 2100;
	mPosY = 2190;

	// Initialize the velocity
	dir = 1;
	frame = 4;
}
void Dog::changePos(int x, int y)
{

	// Initialize the offsets
	mPosX = x;
	mPosY = y;
}

void Dog ::set(int w, int h)
{
	DOG_WIDTH = w;
	DOG_HEIGHT = h;
}
void Dog ::changeFrame(int dir)
{

	if (dir == 0)
	{
		if (frame == 0)
		{
			frame = 1;
		}
		else
		{
			frame = 0;
		}
	}
	else if (dir == 1)
	{
		if (frame == 2)
		{
			frame = 3;
		}
		else
		{
			frame = 2;
		}
	}
	else if (dir == 2)
	{
		if (frame == 4)
		{
			frame = 5;
		}
		else
		{
			frame = 4;
		}
	}
	else if (dir == 3)
	{
		if (frame == 6)
		{
			frame = 7;
		}
		else
		{
			frame = 6;
		}
	}
	else
	{
	}
}
void Dog::move()
{
	if (dir == 0)
	{
		mPosY -= DOG_VEL;
		if (mPosY < 0 || mPosY + DOG_HEIGHT > LEVEL_HEIGHT || mPosX < 0 || mPosX + DOG_WIDTH > LEVEL_WIDTH)
		{
			mPosY += DOG_VEL;
			dir = 1;
		}
		else if (collided())
		{
			mPosY += DOG_VEL;
			dir = 1;
		}
	}
	else if (dir == 1)
	{
		mPosX += DOG_VEL;
		if (mPosY < 0 || mPosY + DOG_HEIGHT > LEVEL_HEIGHT || mPosX < 0 || mPosX + DOG_WIDTH > LEVEL_WIDTH)
		{
			mPosX -= DOG_VEL;
			dir = 2;
		}
		else if (collided())
		{
			mPosX -= DOG_VEL;
			dir = 2;
		}
	}
	else if (dir == 2)
	{
		mPosY += DOG_VEL;
		if (mPosY < 0 || mPosY + DOG_HEIGHT > LEVEL_HEIGHT || mPosX < 0 || mPosX + DOG_WIDTH > LEVEL_WIDTH)
		{
			mPosY -= DOG_VEL;
			dir = 3;
		}
		else if (collided())
		{
			mPosY -= DOG_VEL;
			dir = 3;
		}
	}
	else if (dir == 3)
	{
		mPosX -= DOG_VEL;
		if (mPosY < 0 || mPosY + DOG_HEIGHT > LEVEL_HEIGHT || mPosX < 0 || mPosX + DOG_WIDTH > LEVEL_WIDTH)
		{
			mPosX += DOG_VEL;
			dir = 0;
		}
		else if (collided())
		{
			mPosX += DOG_VEL;
			dir = 0;
		}
	}
	changeFrame(dir);
}
void Dog::render(int camX, int camY, SDL_Rect *clip)
{
	// Show the dot relative to the camera
	gDogTexture.render(mPosX - camX, mPosY - camY, clip);
}

int Dog ::getPosX()
{
	return mPosX;
}
int Dog ::getPosY()
{
	return mPosY;
}

bool Dog ::collided()
{
	bool collided = false;
	// collided = collided||wallCollision(mPosX,mPosY);
	collided = collided || (wallCollision(mPosX, mPosY));
	collided = collided || (wallCollision(mPosX + DOG_WIDTH / 2, mPosY + DOG_HEIGHT / 2));
	collided = collided || (wallCollision(mPosX, mPosY + DOG_HEIGHT / 2));
	collided = collided || (wallCollision(mPosX + DOG_WIDTH / 2, mPosY));
	return collided;
}

Yulu::Yulu()
{
	// Initialize the offsets
	mPosX = 0;
	mPosY = 0;

	// Initialize the velocity
	mVelX = 0;
	mVelY = 0;
	dir = 1;
	frame = 1;
}
void Yulu::reset()
{

	// Initialize the offsets
	mPosX = 0;
	mPosY = 0;

	// Initialize the velocity
	mVelX = 0;
	mVelY = 0;

	dir = 1;
	frame = 1;
}
void Yulu::changePos(int x, int y)
{

	// Initialize the offsets
	mPosX = x;
	mPosY = y;
}

void Yulu::changeFrame(int dir)
{

	if (dir == 0)
	{
		if (frame == 0)
		{
			frame = 1;
		}
		else
		{
			frame = 0;
		}
	}
	else if (dir == 1)
	{
		if (frame == 2)
		{
			frame = 3;
		}
		else
		{
			frame = 2;
		}
	}
	else if (dir == 2)
	{
		if (frame == 4)
		{
			frame = 5;
		}
		else
		{
			frame = 4;
		}
	}
	else if (dir == 3)
	{
		if (frame == 6)
		{
			frame = 7;
		}
		else
		{
			frame = 6;
		}
	}
	else
	{
	}
}

void Yulu::handleEvent()
{
	// If a key was pressed
	SDL_PumpEvents();
	const Uint8 *keystatesyulu = SDL_GetKeyboardState(NULL);
	bool pressed = false;
	if (keystatesyulu[SDL_SCANCODE_LEFT])
	{
		frame = 3;
		wasYuluMoving = true;
		pressed = true;
		mVelX -= YULU_VEL;
		// cout<<"player moved"<<endl;
		cout << "player moved left" << endl;

		// YuluFrame= (YuluFrame+1)%yuluHoldMoveSpeed;
	}
	else
	{
		//  YuluFrame= (YuluFrame+1)%yuluHoldMoveSpeed;
	}
	if (keystatesyulu[SDL_SCANCODE_RIGHT])
	{
		frame = 1;
		wasYuluMoving = true;
		pressed = true;
		mVelX += YULU_VEL;
		cout << "player moved right" << endl;
		// YuluFrame= (YuluFrame+1)%yuluHoldMoveSpeed;
	}
	else
	{
		//  YuluFrame= (YuluFrame+1)%yuluHoldMoveSpeed;
	}
	// if( e.type == SDL_KEYDOWN )
	if (keystatesyulu[SDL_SCANCODE_UP])
	{
		frame = 0;
		wasYuluMoving = true;
		pressed = true;
		mVelY -= YULU_VEL;
		// cout<<"player moved"<<endl;
		cout << "player moved up" << endl;

		// YuluFrame= (YuluFrame+1)%yuluHoldMoveSpeed;
	}
	else
	{
		//  YuluFrame= (YuluFrame+1)%yuluHoldMoveSpeed;
	}
	if (keystatesyulu[SDL_SCANCODE_DOWN])
	{
		frame = 2;
		wasYuluMoving = true;
		pressed = true;
		mVelY += YULU_VEL;
		// cout<<"player moved"<<endl;
		cout << "player moved down" << endl;

		// YuluFrame= (YuluFrame+1)%yuluHoldMoveSpeed;
	}
	else
	{
		//  YuluFrame= (YuluFrame+1)%yuluHoldMoveSpeed;
	}
	if (!keystatesyulu[SDL_SCANCODE_DOWN] && !keystatesyulu[SDL_SCANCODE_UP] && !keystatesyulu[SDL_SCANCODE_RIGHT] && !keystatesyulu[SDL_SCANCODE_LEFT])
	{
		YuluFrame = 0;
		cout << "baar baar" << endl;
	}
	cout << "frame" << YuluFrame << endl;
	YuluFrame = (YuluFrame + 1) % yuluHoldMoveSpeed;
}

bool Yulu::handleEventSingle(SDL_Event &e)
{
	// If a key was pressed
	bool oneTimePress = false;
	if (e.type == SDL_KEYDOWN && e.key.repeat == 0)
	{

		// Adjust the velocity
		switch (e.key.keysym.sym)
		{

		case SDLK_UP:

			frame = 0;
			mVelY -= YULU_VEL;
			oneTimePress = true;
			cout << "player moved" << endl;

			break;
		case SDLK_DOWN:

			frame = 2;
			mVelY += YULU_VEL;
			oneTimePress = true;
			cout << "player moved" << endl;

			break;
		case SDLK_LEFT:

			frame = 3;
			oneTimePress = true;
			mVelX -= YULU_VEL;
			cout << "player moved" << endl;

			break;
		case SDLK_RIGHT:

			frame = 1;
			mVelX += YULU_VEL;
			oneTimePress = true;
			cout << "player moved" << endl;

			break;
		}
	}
	return oneTimePress;
	// If a key was released
}

void Yulu ::set(int w, int h)
{
	YULU_WIDTH = w;
	YULU_HEIGHT = h;
}
void Yulu::move(int camX, int camY)
{
	// Move the dot left or right
	mPosX += mVelX;

	// If the dot went too far to the left or right
	if ((mPosX < 0) || (mPosX + YULU_WIDTH - camX > gWindow.getWidth()))
	{
		// Move back
		mPosX -= mVelX;
	}

	// Move the dot up or down
	mPosY += mVelY;

	// If the dot went too far up or down
	if ((mPosY < 0) || (mPosY + YULU_HEIGHT - camY > gWindow.getHeight()))
	{
		// Move back
		mPosY -= mVelY;
	}
	if (collided())
	{
		mPosX -= mVelX;
		mPosY -= mVelY;
	}
	// cout<<"move"<<endl;
	mVelX = 0;
	mVelY = 0;
}
void Yulu::render(int camX, int camY, SDL_Rect *clip)
{
	// Show the dot relative to the camera
	gYuluSheetTexture.render(mPosX - camX, mPosY - camY, clip);
}

int Yulu ::getPosX()
{
	return mPosX;
}
int Yulu ::getPosY()
{
	return mPosY;
}

bool Yulu ::collided()
{
	bool collided = false;
	// // collided = collided||wallCollision(mPosX,mPosY);
	// collided = collided||(wallCollision(mPosX,mPosY+PLAYER_HEIGHT/2))&&(mPosY%(mapTileSize/2)==0);
	// // collided = collided||(wallCollision(mPosX+PLAYER_WIDTH,mPosY)&&(mPosX%mapTileSize==0));
	// collided = collided||(wallCollision(mPosX+PLAYER_WIDTH,mPosY+PLAYER_HEIGHT/2)&&(mPosY%(mapTileSize/2)==0)&&(mPosX%(mapTileSize/2)!=0));
	// collided = collided||(wallCollision(mPosX,mPosY+PLAYER_HEIGHT)&&(mPosY%(mapTileSize/2)!=0));
	// collided = collided||(wallCollision(mPosX+PLAYER_WIDTH,mPosY+PLAYER_HEIGHT)&&(mPosY%(mapTileSize/2)!=0));
	// return collided;

	collided = collided || wallCollision(mPosX, mPosY);
	collided = collided || (wallCollision(mPosX, mPosY + YULU_WIDTH/2));
	collided = collided || (wallCollision(mPosX + YULU_WIDTH/2, mPosY + YULU_WIDTH/2));
	collided = collided || (wallCollision(mPosX + YULU_WIDTH/2, mPosY));
	return collided;
}

LTimer::LTimer()
{
	// Initialize the variables
	mStartTicks = 0;
	mPausedTicks = 0;

	mPaused = false;
	mStarted = false;
}

void LTimer::start()
{
	// Start the timer
	mStarted = true;

	// Unpause the timer
	mPaused = false;

	// Get the current clock time
	mStartTicks = SDL_GetTicks();
	mPausedTicks = 0;
}

void LTimer::stop()
{
	// Stop the timer
	mStarted = false;

	// Unpause the timer
	mPaused = false;

	// Clear tick variables
	mStartTicks = 0;
	mPausedTicks = 0;
}

void LTimer::pause()
{
	// If the timer is running and isn't already paused
	if (mStarted && !mPaused)
	{
		// Pause the timer
		mPaused = true;

		// Calculate the paused ticks
		mPausedTicks = SDL_GetTicks() - mStartTicks;
		mStartTicks = 0;
	}
}

void LTimer::unpause()
{
	// If the timer is running and paused
	if (mStarted && mPaused)
	{
		// Unpause the timer
		mPaused = false;

		// Reset the starting ticks
		mStartTicks = SDL_GetTicks() - mPausedTicks;

		// Reset the paused ticks
		mPausedTicks = 0;
	}
}

Uint32 LTimer::getTicks()
{
	// The actual timer time
	Uint32 time = 0;

	// If the timer is running
	if (mStarted)
	{
		// If the timer is paused
		if (mPaused)
		{
			// Return the number of ticks when the timer was paused
			time = mPausedTicks;
		}
		else
		{
			// Return the current time minus the start time
			time = SDL_GetTicks() - mStartTicks;
		}
	}

	return time;
}

bool LTimer::isStarted()
{
	// Timer is running and paused or unpaused
	return mStarted;
}

bool LTimer::isPaused()
{
	// Timer is running and paused
	return mPaused && mStarted;
}

LTexture::LTexture()
{
	// Initialize
	mTexture = NULL;
	mWidth = 0;
	mHeight = 0;
}

LTexture::~LTexture()
{
	// Deallocate
	free();
}

bool LTexture::loadFromFile(std::string path)
{
	// Get rid of preexisting texture
	free();

	// The final texture
	SDL_Texture *newTexture = NULL;

	// Load image at specified path
	SDL_Surface *loadedSurface = IMG_Load(path.c_str());
	if (loadedSurface == NULL)
	{
		printf("Unable to load image %s! SDL_image Error: %s\n", path.c_str(), IMG_GetError());
	}
	else
	{
		// Color key image
		SDL_SetColorKey(loadedSurface, SDL_TRUE, SDL_MapRGB(loadedSurface->format, 0, 0xFF, 0xFF));

		// Create texture from surface pixels
		newTexture = SDL_CreateTextureFromSurface(gRenderer, loadedSurface);
		if (newTexture == NULL)
		{
			printf("Unable to create texture from %s! SDL Error: %s\n", path.c_str(), SDL_GetError());
		}
		else
		{
			// Get image dimensions
			mWidth = loadedSurface->w;
			mHeight = loadedSurface->h;
		}

		// Get rid of old loaded surface
		SDL_FreeSurface(loadedSurface);
	}

	// Return success
	mTexture = newTexture;
	return mTexture != NULL;
}

void LTexture::set(int w, int h)
{
	mWidth = w;
	mHeight = h;
}

#if defined(SDL_TTF_MAJOR_VERSION)
bool LTexture::loadFromRenderedText(std::string textureText, SDL_Color textColor)
{
	// Get rid of preexisting texture
	free();

	// Render text surface
	SDL_Surface *textSurface = TTF_RenderText_Solid(gFont, textureText.c_str(), textColor);
	if (textSurface != NULL)
	{
		// Create texture from surface pixels
		mTexture = SDL_CreateTextureFromSurface(gRenderer, textSurface);
		if (mTexture == NULL)
		{
			printf("Unable to create texture from rendered text! SDL Error: %s\n", SDL_GetError());
		}
		else
		{
			// Get image dimensions
			mWidth = textSurface->w;
			mHeight = textSurface->h;
		}

		// Get rid of old surface
		SDL_FreeSurface(textSurface);
	}
	else
	{
		printf("Unable to render text surface! SDL_ttf Error: %s\n", TTF_GetError());
	}

	// Return success
	return mTexture != NULL;
}
#endif

void LTexture::free()
{
	// Free texture if it exists
	if (mTexture != NULL)
	{
		SDL_DestroyTexture(mTexture);
		mTexture = NULL;
		mWidth = 0;
		mHeight = 0;
	}
}

void LTexture::setColor(Uint8 red, Uint8 green, Uint8 blue)
{
	// Modulate texture rgb
	SDL_SetTextureColorMod(mTexture, red, green, blue);
}

void LTexture::setBlendMode(SDL_BlendMode blending)
{
	// Set blending function
	SDL_SetTextureBlendMode(mTexture, blending);
}

void LTexture::setAlpha(Uint8 alpha)
{
	// Modulate texture alpha
	SDL_SetTextureAlphaMod(mTexture, alpha);
}

void LTexture::render(int x, int y, SDL_Rect *clip, double angle, SDL_Point *center, SDL_RendererFlip flip)
{
	// Set rendering space and render to screen
	SDL_Rect renderQuad = {x, y, mWidth, mHeight};

	// Set clip rendering dimensions
	//  if( clip != NULL )
	//  {
	//  	renderQuad.w = clip->w;
	//  	renderQuad.h = clip->h;
	//  }

	// Render to screen
	SDL_RenderCopyEx(gRenderer, mTexture, clip, &renderQuad, angle, center, flip);
}

int LTexture::getWidth()
{
	return mWidth;
}

int LTexture::getHeight()
{
	return mHeight;
}

LWindow::LWindow()
{
	// Initialize non-existant window
	mWindow = NULL;
	mMouseFocus = false;
	mKeyboardFocus = false;
	mFullScreen = false;
	mMinimized = false;
	mWidth = 0;
	mHeight = 0;
}

bool LWindow::init()
{
	// Create window
	mWindow = SDL_CreateWindow("SDL Tutorial", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
	if (mWindow != NULL)
	{
		mMouseFocus = true;
		mKeyboardFocus = true;
		mWidth = SCREEN_WIDTH;
		mHeight = SCREEN_HEIGHT;
	}

	return mWindow != NULL;
}

SDL_Renderer *LWindow::createRenderer()
{
	return SDL_CreateRenderer(mWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
}

void LWindow::handleEvent(SDL_Event &e)
{
	// Window event occured
	if (e.type == SDL_WINDOWEVENT)
	{
		// Caption update flag
		bool updateCaption = false;

		switch (e.window.event)
		{
		// Get new dimensions and repaint on window size change
		case SDL_WINDOWEVENT_SIZE_CHANGED:
			mWidth = e.window.data1;
			mHeight = e.window.data2;
			SDL_RenderPresent(gRenderer);
			break;

		// Repaint on exposure
		case SDL_WINDOWEVENT_EXPOSED:
			SDL_RenderPresent(gRenderer);
			break;

		// Mouse entered window
		case SDL_WINDOWEVENT_ENTER:
			mMouseFocus = true;
			updateCaption = true;
			break;

		// Mouse left window
		case SDL_WINDOWEVENT_LEAVE:
			mMouseFocus = false;
			updateCaption = true;
			break;

		// Window has keyboard focus
		case SDL_WINDOWEVENT_FOCUS_GAINED:
			mKeyboardFocus = true;
			updateCaption = true;
			break;

		// Window lost keyboard focus
		case SDL_WINDOWEVENT_FOCUS_LOST:
			mKeyboardFocus = false;
			updateCaption = true;
			break;

		// Window minimized
		case SDL_WINDOWEVENT_MINIMIZED:
			mMinimized = true;
			break;

		// Window maxized
		case SDL_WINDOWEVENT_MAXIMIZED:
			mMinimized = false;
			break;

		// Window restored
		case SDL_WINDOWEVENT_RESTORED:
			mMinimized = false;
			break;
		}

		// Update window caption with new data
		if (updateCaption)
		{
			std::stringstream caption;
			caption << "SDL Tutorial - MouseFocus:" << ((mMouseFocus) ? "On" : "Off") << " KeyboardFocus:" << ((mKeyboardFocus) ? "On" : "Off");
			SDL_SetWindowTitle(mWindow, caption.str().c_str());
		}
	}
	// Enter exit full screen on return key
	else if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_F11)
	{
		if (mFullScreen)
		{
			SDL_SetWindowFullscreen(mWindow, SDL_FALSE);
			mFullScreen = false;
		}
		else
		{
			SDL_SetWindowFullscreen(mWindow, SDL_TRUE);
			mFullScreen = true;
			mMinimized = false;
		}
	}
}

void LWindow::free()
{
	if (mWindow != NULL)
	{
		SDL_DestroyWindow(mWindow);
	}

	mMouseFocus = false;
	mKeyboardFocus = false;
	mWidth = 0;
	mHeight = 0;
}

int LWindow::getWidth()
{
	return mWidth;
}

int LWindow::getHeight()
{
	return mHeight;
}

bool LWindow::hasMouseFocus()
{
	return mMouseFocus;
}

bool LWindow::hasKeyboardFocus()
{
	return mKeyboardFocus;
}

bool LWindow::isMinimized()
{
	return mMinimized;
}

bool init()
{
	// Initialization flag
	bool success = true;

	// Initialize SDL
	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0)
	{
		printf("SDL could not initialize! SDL Error: %s\n", SDL_GetError());
		success = false;
	}
	else
	{
		// Set texture filtering to linear
		if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1"))
		{
			printf("Warning: Linear texture filtering not enabled!");
		}

		// Create window
		if (!gWindow.init())
		{
			printf("Window could not be created! SDL Error: %s\n", SDL_GetError());
			success = false;
		}
		else
		{
			// Create renderer for window
			gRenderer = gWindow.createRenderer();
			if (gRenderer == NULL)
			{
				printf("Renderer could not be created! SDL Error: %s\n", SDL_GetError());
				success = false;
			}
			else
			{
				// Initialize renderer color
				SDL_SetRenderDrawColor(gRenderer, 0xFF, 0xFF, 0xFF, 0xFF);

				// Initialize PNG loading
				int imgFlags = IMG_INIT_PNG;
				if (!(IMG_Init(imgFlags) & imgFlags))
				{
					printf("SDL_image could not initialize! SDL_image Error: %s\n", IMG_GetError());
					success = false;
				}
				if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0)
				{
					printf("SDL_mixer could not initialize! SDL_mixer Error: %s\n", Mix_GetError());
					success = false;
				}

				// Initialize SDL_ttf
				if (TTF_Init() == -1)
				{
					printf("SDL_ttf could not initialize! SDL_ttf Error: %s\n", TTF_GetError());
					success = false;
				}
			}
		}
	}

	return success;
}

class Button
{
private:
	// The attributes of the button
	SDL_Rect box;

	// The part of the button sprite sheet that will be shown
	string mButton;
	string mBefore;
	string mHover;

public:
	// Initialize the variables
	Button(int x, int y, int w, int h, string beforeButton, string afterButton);
	void set(int x, int y, int w, int h);
	// Handles events and set the button's sprite region
	int handle_events(SDL_Event &event, int playOrNot, int server, int beforegame);

	// Shows the button on the screen
	void show();
};

Button::Button(int x, int y, int w, int h, string beforeButton, string afterButton)
{
	// Set the button's attributes
	box.x = x;
	box.y = y;
	box.w = w;
	box.h = h;

	// Set the default button textures
	mBefore = beforeButton;
	mHover = afterButton;
}

void Button::set(int x, int y, int w, int h)
{
	// Set the button's attributes
	box.x = x;
	box.y = y;
	box.w = w;
	box.h = h;
}

int Button::handle_events(SDL_Event &event, int playOrNot, int server, int beforegame)
{
	// The mouse offsets
	int x = 0, y = 0;

	// If the mouse moved

	// Get the mouse offsets
	//  x = event.motion.x;
	//  y = event.motion.y;
	//  SDL_PumpEvents();
	SDL_GetMouseState(&x, &y);

	// If the mouse is over the button
	if ((x > box.x) && (x < box.x + box.w) && (y > box.y) && (y < box.y + box.h))
	{

		// Set the button sprite
		mButton = mHover;
	}
	// If not
	else
	{
		// Set the button sprite
		mButton = mBefore;
	}
	// //If a mouse button was pressed
	if (event.type == SDL_MOUSEBUTTONDOWN)
	{
		// If the left mouse button was pressed
		if (event.button.button == SDL_BUTTON_LEFT)
		{
			// Get the mouse offsets
			x = event.button.x;
			y = event.button.y;

			// If the mouse is over the button
			if ((x > box.x) && (x < box.x + box.w) && (y > box.y) && (y < box.y + box.h))
			{
				// Set the button sprite
				play = playOrNot;
				if (beforegame == 1)
				{
					if (server == 1)
					{
						return 9;
					}
					if (server == 0)
					{
						return 10;
					}
				}
			}
		}
		return 0;
		// hi
	}
}
void Button::show()
{
	// Show the button
	LTexture ButtonNew;
	ButtonNew.loadFromFile(mButton);
	ButtonNew.set(box.w, box.h);
	ButtonNew.render(box.x, box.y);
}

bool isPlayerInside(int x,int y,int w,int h ){
	if(player1.getPosX()>=x && player1.getPosX()<=x+w && player1.getPosY()>y-(mapTileSize*3)/4 && player1.getPosY()<=y+h)
	{
		return true;
	}
	else{
		return false;
	}
}

void displayDrink(int x,int y,int w, int h)
{
	if(player1.getPosX()>=x && player1.getPosX()<=x+w && player1.getPosY()>y && player1.getPosY()-(mapTileSize*3)/4<=y+h)
	{
		drinkTexture.loadFromRenderedText("Buy Drink for 50 and increase happiness by 1(Press D)",white);
		drinkTexture.render(gWindow.getWidth() / 2 - drinkTexture.getWidth() / 2, gWindow.getHeight() - drinkTexture.getHeight() * 4);
	}
}


void buyDrink(SDL_Event& e){
	if(e.type==SDL_KEYDOWN && e.key.keysym.sym == SDLK_d && playerScore.money>=50 ){
		playerScore.changeHappiness(1);
		playerScore.changeMoney(-50);
	}
}

void displayFood(int x,int y,int w, int h)
{
	if(player1.getPosX()>=x && player1.getPosX()<=x+w && player1.getPosY()>y && player1.getPosY()-(mapTileSize*3)/4<=y+h)
	{
		foodTexture.loadFromRenderedText("Buy Burger for 80  and increase happiness by 1 and health by 10(Press B)",white);
		foodTexture.render(gWindow.getWidth() / 2 - foodTexture.getWidth() / 2, gWindow.getHeight() - foodTexture.getHeight() * 2);
	}
}

void buyFood(SDL_Event& e){
	if(e.type==SDL_KEYDOWN && e.key.keysym.sym == SDLK_b && playerScore.money>=50 ){
		playerScore.changeHappiness(1);
		playerScore.changeHealth(10);
		playerScore.changeMoney(-80);
	}
}
void playGame(SDL_Event& e){
	if(e.type==SDL_KEYDOWN && e.key.keysym.sym == SDLK_p && playerScore.money>=20 ){
		playerScore.changeMoney(-20);
		play =3;
	}
}

void displayGame(int x,int y,int w, int h)
{
	if(player1.getPosX()>=x && player1.getPosX()<=x+w && player1.getPosY()>=y - (mapTileSize*3)/4 && player1.getPosY()<=y+h)
	{
		jumpGameTexture.loadFromRenderedText("Play jump over the box- price =30 (Press P)",white);
		jumpGameTexture.render(gWindow.getWidth() / 2 - jumpGameTexture.getWidth() / 2, gWindow.getHeight() - jumpGameTexture.getHeight() * 4);
	} 
}

bool loadMedia()
{
	// Loading success flag
	bool success = true;

	// Load scene texture
	// Load music

	//Load sprite sheet texture
	if( !gManTexture.loadFromFile( "foo.png" ) )
	{
		printf( "Failed to load walking animation texture!\n" );
		success = false;
	}
	else
	{
		//Set sprite clips
		gBouncingManClips[ 0 ].x =   0;
		gBouncingManClips[ 0 ].y =   0;
		gBouncingManClips[ 0 ].w =  64;
		gBouncingManClips[ 0 ].h = 205;

		gBouncingManClips[ 1 ].x =  64;
		gBouncingManClips[ 1 ].y =   0;
		gBouncingManClips[ 1 ].w =  64;
		gBouncingManClips[ 1 ].h = 205;
		
		gBouncingManClips[ 2 ].x = 128;
		gBouncingManClips[ 2 ].y =   0;
		gBouncingManClips[ 2 ].w =  64;
		gBouncingManClips[ 2 ].h = 205;

		gBouncingManClips[ 3 ].x = 192;
		gBouncingManClips[ 3 ].y =   0;
		gBouncingManClips[ 3 ].w =  64;
		gBouncingManClips[ 3 ].h = 205;
	}
	if( !gBoxDinoTexture.loadFromFile( "crate.png" ) )
	{
		printf( "Failed to load crate!\n" );
		success = false;
	}
	gBoxDinoTexture.set(50,50);
	if( !gTreeTexture.loadFromFile( "tree.jpg" ) )
	{
		printf( "Failed to load walking animation texture!\n" );
		success = false;
	}
	gTreeTexture.set(1800,900);
	gManTexture.set(64,205);
	
	gMusic = Mix_LoadMUS("beat.wav");
	if (gMusic == NULL)
	{
		printf("Failed to load beat music! SDL_mixer Error: %s\n", Mix_GetError());
		success = false;
	}

	// Load sound effects
	grun = Mix_LoadWAV("scratch.wav");
	if (grun == NULL)
	{
		printf("Failed to load scratch sound effect! SDL_mixer Error: %s\n", Mix_GetError());
		success = false;
	}

	gyulu = Mix_LoadWAV("high.wav");
	if (gyulu == NULL)
	{
		printf("Failed to load high sound effect! SDL_mixer Error: %s\n", Mix_GetError());
		success = false;
	}

	if (!gBackgroundStartScreenTexture.loadFromFile("../assets/gamebg.png"))
	{
		printf("Failed to load background texture!\n");
		success = false;
	}
	if (!gProfessorTexture.loadFromFile("../assets/woman1.jpg"))
	{
		printf("Failed to load professor\n");
		success = false;
	}

	if (!gHeartTexture.loadFromFile("../assets/heart.png"))
	{
		printf("Failed to load heart!\n");
		success = false;
	}
	if (!gCoinTexture.loadFromFile("../assets/coin.png"))
	{
		printf("Failed to load coin!\n");
		success = false;
	}
	if (!gHappinessTexture.loadFromFile("../assets/happy.png"))
	{
		printf("Failed to load happiness!\n");
		success = false;
	}
	if (!gBoxTexture.loadFromFile("../assets/box.png"))
	{
		printf("Failed to load happiness!\n");
		success = false;
	}

	if (!ghelpsectionbg.loadFromFile("../assets/helpbg.png"))
	{
		printf("Failed to load background texture!\n");
		success = false;
	}
	if (!gPlayBefore.loadFromFile("../assets/purplepad.png"))
	{
		printf("Failed to load play button!\n");
		success = false;
	}
	if (!gPlayHover.loadFromFile("../assets/playHover.png"))
	{
		printf("Failed to load play button on hover!\n");
		success = false;
	}
	if (!gYuluStandRectTexture.loadFromFile("../assets/yulurect.png"))
	{
		printf("Failed to load yulu stand!\n");
		success = false;
	}
	if (!gYuluStandSqTexture.loadFromFile("../assets/yulusquare.png"))
	{
		printf("Failed to load yulu stand!\n");
		success = false;
	}

	gFont = TTF_OpenFont("../assets/Bevan.ttf", 28);
	if (gFont == NULL)
	{
		printf("Failed to load lazy font! SDL_ttf Error: %s\n", TTF_GetError());
		success = false;
	}
	if (!gSpriteSheetTexture.loadFromFile("../assets/movingman.png"))
	{
		printf("Failed to load walking animation texture!\n");
		success = false;
	}

	else
	{
		// Set sprite clips
		gSpriteClips[0].x = 0;
		gSpriteClips[0].y = 0;
		gSpriteClips[0].w = 114;
		gSpriteClips[0].h = 184.5;

		gSpriteClips[1].x = 0;
		gSpriteClips[1].y = 232.5;
		gSpriteClips[1].w = 114;
		gSpriteClips[1].h = 184.5;

		gSpriteClips[2].x = 390;
		gSpriteClips[2].y = 0;
		gSpriteClips[2].w = 126;
		gSpriteClips[2].h = 184.5;

		gSpriteClips[3].x = 390;
		gSpriteClips[3].y = 232.5;
		gSpriteClips[3].w = 126;
		gSpriteClips[3].h = 184.5;

		gSpriteClips[4].x = 265;
		gSpriteClips[4].y = 0;
		gSpriteClips[4].w = 114;
		gSpriteClips[4].h = 184.5;

		gSpriteClips[5].x = 265;
		gSpriteClips[5].y = 232.5;
		gSpriteClips[5].w = 114;
		gSpriteClips[5].h = 184.5;

		gSpriteClips[6].x = 118;
		gSpriteClips[6].y = 0;
		gSpriteClips[6].w = 135;
		gSpriteClips[6].h = 184.5;

		gSpriteClips[7].x = 118;
		gSpriteClips[7].y = 237;
		gSpriteClips[7].w = 135;
		gSpriteClips[7].h = 184.5;
	}
	if (!gDogTexture.loadFromFile("../assets/dogSheet.png"))
	{
		printf("Failed to load walking animation texture!\n");
		success = false;
	}
	else
	{
		// Set sprite clips
		gDogClips[0].x = 0;
		gDogClips[0].y = 0;
		gDogClips[0].w = 200;
		gDogClips[0].h = 200;

		gDogClips[1].x = 200;
		gDogClips[1].y = 0;
		gDogClips[1].w = 200;
		gDogClips[1].h = 200;

		gDogClips[2].x = 400;
		gDogClips[2].y = 400;
		gDogClips[2].w = 200;
		gDogClips[2].h = 200;

		gDogClips[3].x = 600;
		gDogClips[3].y = 400;
		gDogClips[3].w = 200;
		gDogClips[3].h = 200;

		gDogClips[4].x = 400;
		gDogClips[4].y = 0;
		gDogClips[4].w = 200;
		gDogClips[4].h = 200;

		gDogClips[5].x = 600;
		gDogClips[5].y = 0;
		gDogClips[5].w = 200;
		gDogClips[5].h = 200;

		gDogClips[6].x = 0;
		gDogClips[6].y = 400;
		gDogClips[6].w = 200;
		gDogClips[6].h = 200;

		gDogClips[7].x = 200;
		gDogClips[7].y = 400;
		gDogClips[7].w = 200;
		gDogClips[7].h = 200;
	}
	if (!gYuluSheetTexture.loadFromFile("../assets/bike.png"))
	{
		printf("Failed to load walking animation texture!\n");
		success = false;
	}
	else
	{
		// Set sprite clips
		gYuluClips[0].x = 0;
		gYuluClips[0].y = 0;
		gYuluClips[0].w = 120;
		gYuluClips[0].h = 181;

		gYuluClips[1].x = 220;
		gYuluClips[1].y = 0;
		gYuluClips[1].w = 181;
		gYuluClips[1].h = 120;

		gYuluClips[2].x = 120;
		gYuluClips[2].y = 0;
		gYuluClips[2].w = 120;
		gYuluClips[2].h = 181;

		gYuluClips[3].x = 220;
		gYuluClips[3].y = 120;
		gYuluClips[3].w = 181;
		gYuluClips[3].h = 120;
	}

	return success;
}

void close()
{
	ofstream file;
	file.open("matrix.txt");
	for (int i = 0; i < 80; i++)
	{
		for (int j = 0; j < 140; j++)
		{
			file << temp[i][j] << ", ";
		}
		file << endl;
	}
	// Free loaded images
	gBackgroundStartScreenTexture.free();

	// Destroy window
	SDL_DestroyRenderer(gRenderer);
	gWindow.free();

	// Quit SDL subsystems
	IMG_Quit();
	SDL_Quit();
}

bool CheckCaught()
{
	bool caught = false;
	// SDL_Color white = {255, 255, 255, 255};
	if (player1.getPosX() >= professor1.getPosX() - 3 * mapTileSize && player1.getPosX() < professor1.getPosX() + mapTileSize * 7 / 2 && player1.getPosY() >= professor1.getPosY() - 3 * mapTileSize && player1.getPosY() < professor1.getPosY() + mapTileSize * 4)
	{
		caught = true;
		playerScore.changeHappiness(-1);
		player1.changePos(7200, 1380);
	}
	if (player1.getPosX() >= dog1.getPosX() - mapTileSize && player1.getPosX() < dog1.getPosX() + mapTileSize * 2 && player1.getPosY() >= dog1.getPosY() - mapTileSize && player1.getPosY() < dog1.getPosY() + mapTileSize * 2)
	{
		caught = true;
		playerScore.changeHealth(-10);
		player1.changePos(4800, 2040);
		// dogTextTexture.loadFromRenderedText("Ahhhh......",white);
		// dogTextTexture.render(gWindow.getWidth()/2-yuluText.getWidth()/2,gWindow.getHeight()-yuluText.getHeight()*4);
		// SDL_RenderPresent(gRenderer);
		// SDL_Delay(1000);
	}

	return caught;
}

int intchker(char a)
{
	if (a >= 48 && a <= 57)
	{
		return 2;
	}
	if (a == '+')
	{
		return 1;
	}
	return 0;
}

char *datasend(int *arr, int noofdata)
{
	int *list = new int[100];
	for (int i = 0; i < noofdata; i++)
	{
		/* code */
		list[i] = arr[i];
	}
	string sum = "";
	for (int i = 0; i < noofdata; i++)
	{
		/* code */
		sum += to_string(list[i]);
		sum += "_";
	}
	int len = sum.length();
	char *data = new char[len];

	for (size_t i = 0; i < len; i++)
	{
		/* code */
		data[i] = sum.at(i);
	}

	return data;
}

int *datarecv(char *arr, int noofdata)
{
	int *receiveddata = new int[noofdata];
	int count = 0;
	int itr = 0;
	string s = "";
	while (count < noofdata)
	{
		if (arr[itr] == '_')
		{
			receiveddata[count] = std::stoi(s);
			count++;
			s = "";
		}
		else
		{
			s.push_back(arr[itr]);
		}

		itr++;
	}

	cout << receiveddata[2] << " frame sent" << endl;

	return receiveddata;
}

int main(int argc, char *args[])
{
	int mainchk = 0;
	int verticalloc = 680;
	// Start up SDL and create window
	if (!init())
	{
		printf("Failed to initialize!\n");
	}
	else
	{
		// Load media
		if (!loadMedia())
		{
			printf("Failed to load media!\n");
		}
		else
		{

			// Main loop flag
			bool quit = false;

			// Make the button
			string beforePlay = "../assets/purplepad.png";
			string beforeQuit = "../assets/quitBefore.png";
			string hoverPlay = "../assets/playHover.png";
			string hoverQuit = "../assets/quitHover.png";
			string helpus = "../assets/helpus.png";
			string hoverhelpus = "../assets/helpusHover.png";

			string beforePlay2 = "../assets/playbutton2.png";
			string hoverPlay2 = "../assets/playbutton2Hover.png";

			string backbutton = "../assets/back.png";
			string backbuttonHover = "../assets/backHoveer.png";
			// Button playButton( gWindow.getWidth()/2-gWindow.getWidth()/10, gWindow.getHeight()/3-gWindow.getHeight()/10, gWindow.getWidth()/5, gWindow.getHeight()/5, beforePlay,hoverPlay );
			Button quitButton(gWindow.getWidth() - gWindow.getWidth() / 5, 0, gWindow.getWidth() / 5, gWindow.getHeight() / 10, beforeQuit, hoverQuit);

			Button playButton2(gWindow.getWidth() / 2 - gWindow.getWidth() / 10, gWindow.getHeight() / 3 - gWindow.getHeight() / 10, gWindow.getWidth() / 4, gWindow.getHeight() / 4, beforePlay, hoverPlay);

			Button playButton1(gWindow.getWidth() / 2 - gWindow.getWidth() / 10, gWindow.getHeight() / 3 - gWindow.getHeight() / 10, gWindow.getWidth() / 4, gWindow.getHeight() / 4, beforePlay2, hoverPlay2);
			Button helpus1((gWindow.getWidth() * 9) / 10 - gWindow.getWidth() / 10, (gWindow.getHeight() * 9) / 10 - gWindow.getHeight() / 10, gWindow.getWidth() / 10, gWindow.getHeight() / 10, helpus, hoverhelpus);

			Button back((gWindow.getWidth() * 9) / 10 - gWindow.getWidth() / 10, (gWindow.getHeight() * 9) / 10 - gWindow.getHeight() / 10, gWindow.getWidth() / 10, gWindow.getHeight() / 10, backbutton, backbuttonHover);

			bool eraseMark = false;
			// Event handler
			SDL_Event e;
			SDL_Rect camera = {0, 0, gWindow.getWidth(), gWindow.getHeight()};
			SDL_Rect bg = {0, 0, gWindow.getWidth(), gWindow.getHeight()};
			int prevposX = 0;
			int prevposY = 0;
			int curposX = 0;
			int curposY = 0;
			int row, col;
			bool onYulu1 = false;
			bool onYulu2 = false;
			professor1.changePos(5940, 1020);
			dog1.changePos(2100, 2190);

			SDL_Rect ground;
				ground.x = 0;
				ground.y = 300+205;
				ground.h = SCREEN_HEIGHT-300;
				ground.w = SCREEN_WIDTH;
			
			
			//Main loop flag
			bool pause = false;

			//Current animation frame
			int dinoFrame = 0;
			start : 
			double backg1loc = 0,backg2loc = 1800;
			deque<SDL_Rect> obstacles;
			deque<double> backGloc;
			double L = 0;
			for(int i = 0;i<3;++i ){
				backGloc.push_back(L);
				L += 1800;
			}
			SDL_Rect temp;
			double j = 500.0;
			int jumps = 1;
			double speed = 3.0;

			for(int i = 0;i<5;++i ){
				j += (600+rand()%800);
				temp.x = j;
				temp.y = verticalloc+205-50;
				temp.h = 50;
				temp.w = 50;
				obstacles.push_back(temp);

			}
			double startVel=10;
			double vert =  0.0,vert_velocity = 0.0,g = 0.8;	
			//While application is running
			SDL_Rect* backG1 = new SDL_Rect;
			SDL_Rect* Box = new SDL_Rect;
			
			backG1->x = 0;
			backG1->y = 0;
			backG1->w = 1800;
			backG1->h = 900;
			Box->x = 0;
			Box->y = 0;
			Box->w = 250;
			Box->h = 250;

			while (!quit)
			{

				// Handle events on queue
				while (SDL_PollEvent(&e) != 0)
				{

					if (play == 0)
					{
						back.handle_events(e, 2, 2, 2);
					}
					else if (play == 2)
					{

						helpus1.handle_events(e, 0, 1, 0);

						if (playButton1.handle_events(e, 1, 0, 1) == 10)
						{
							mainchk = 10;

							break;
						}

						if (playButton2.handle_events(e, 1, 1, 1) == 9)
						{
							mainchk = 9;

							break;
						}
					}

					if (e.type == SDL_QUIT)
					{
						quit = true;
					}
					// //for handing keys for temp
					// if( e.type == SDL_KEYDOWN &&e.key.keysym.sym == SDLK_RCTRL){
					// 		row = mapElement(curposX,curposY)/xNoSquares;
					// 		col = mapElement(curposX,curposY)%xNoSquares;
					// 		temp[row][col]=0;
					// }
					// else if(e.type==SDL_KEYDOWN &&e.key.keysym.sym == SDLK_LCTRL){
					// 	if(eraseMark==false){
					// 		eraseMark=true;
					// 	}
					// 	else{
					// 		eraseMark= false;
					// 	}
					// }
					//
					// prevposX=curposX;
					// prevposY=curposY;
					// Handle window events
					gWindow.handleEvent(e);
				}

				// Only draw when not minimized
				if (mainchk == 9 || mainchk == 10)
				{
					break;
				}
				else
				{

					if (!gWindow.isMinimized())
					{

						if (play == 0)
						{
							// help screen

							ghelpsectionbg.set(gWindow.getWidth(), gWindow.getHeight());
							ghelpsectionbg.render(0, 0);

							back.set((gWindow.getWidth() * 90) / 100 - gWindow.getWidth() / 10, (gWindow.getHeight() * 995) / 1000 - gWindow.getHeight() / 10, (gWindow.getWidth() * 30) / 100, (gWindow.getHeight() * 5) / 100);
							back.show();

							SDL_RenderPresent(gRenderer);
						}
						else if (play == 2)
						{
							// start screen

							player1.changePos(30, 0);
							player2.changePos(90, 0);
							yulu1.reset();
							professor1.reset();
							dog1.reset();
							playerScore.reset();
							// playButton.set( gWindow.getWidth()/2-gWindow.getWidth()/10, gWindow.getHeight()/3-gWindow.getHeight()/10, gWindow.getWidth()/5, gWindow.getHeight()/5 );
							playButton2.set((gWindow.getWidth() * 37) / 100 - gWindow.getWidth() / 10, (gWindow.getHeight() * 69) / 100 - gWindow.getHeight() / 10, gWindow.getWidth() / 2, gWindow.getHeight() / 8);
							playButton1.set((gWindow.getWidth() * 37) / 100 - gWindow.getWidth() / 10, (gWindow.getHeight() * 79) / 100 - gWindow.getHeight() / 10, gWindow.getWidth() / 2, gWindow.getHeight() / 8);
							helpus1.set((gWindow.getWidth() * 90) / 100 - gWindow.getWidth() / 10, (gWindow.getHeight() * 995) / 1000 - gWindow.getHeight() / 10, (gWindow.getWidth() * 30) / 100, (gWindow.getHeight() * 5) / 100);

							SDL_Color textColor = {255, 255, 255, 255};
							string newGame = "New Game";
							string quit = "Quit";
							quitText.loadFromRenderedText(quit, textColor);
							gBackgroundStartScreenTexture.set(gWindow.getWidth(), gWindow.getHeight());
							gBackgroundStartScreenTexture.render(0, 0);

							// playButton.show();
							playButton2.show();
							playButton1.show();
							helpus1.show();

							// Update screen
							SDL_RenderPresent(gRenderer);
						} 

					}
				}
			}

			cout << mainchk;
			Mix_PlayMusic(gMusic, -1);

			int server_fd, new_socketserv, valreadserv;
			struct sockaddr_in addressserv;
			int optserv = 1;
			int addrlenserv = sizeof(addressserv);
			char bufferserv[60] = {0};
			char *helloserv = "Hello from server";

			if (mainchk == 9)

			{

				// Creating socket file descriptor
				if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
				{
					perror("socket failed");
					exit(EXIT_FAILURE);
				}

				// Forcefully attaching socket to the port 8080
				if (setsockopt(server_fd, SOL_SOCKET,
							   SO_REUSEADDR | SO_REUSEPORT, &optserv,
							   sizeof(optserv)))
				{
					perror("setsockopt");
					exit(EXIT_FAILURE);
				}
				addressserv.sin_family = AF_INET;
				addressserv.sin_addr.s_addr = INADDR_ANY;
				addressserv.sin_port = htons(PORT);

				// Forcefully attaching socket to the port 8080
				if (bind(server_fd, (struct sockaddr *)&addressserv,
						 sizeof(addressserv)) < 0)
				{
					perror("bind failed");
					exit(EXIT_FAILURE);
				}
				if (listen(server_fd, 3) < 0)
				{
					perror("listen");
					exit(EXIT_FAILURE);
				}
				if ((new_socketserv = accept(server_fd, (struct sockaddr *)&addressserv,
											 (socklen_t *)&addrlenserv)) < 0)
				{
					perror("accept");
					exit(EXIT_FAILURE);
				}
				valreadserv = read(new_socketserv, bufferserv, 60);
				printf("%s\n", bufferserv);
				send(new_socketserv, helloserv, strlen(helloserv), 0);
				printf("Hello message sent\n");
			}

			int sockcl = 0, valreadcl;
			struct sockaddr_in serv_addrcl;
			char *hellocl = "Hello from client";
			char buffercl[60] = {0};

			if (mainchk == 10)
			{
				if ((sockcl = socket(AF_INET, SOCK_STREAM, 0)) < 0)
				{
					printf("\n Socket creation error \n");
					return -1;
				}

				serv_addrcl.sin_family = AF_INET;
				serv_addrcl.sin_port = htons(PORT);

				// Convert IPv4 and IPv6 addresses from text to binary
				// form
				if (inet_pton(AF_INET, "127.0.0.1", &serv_addrcl.sin_addr) <= 0)
				{
					printf(
						"\nInvalid address/ Address not supported \n");
					return -1;
				}

				if (connect(sockcl, (struct sockaddr *)&serv_addrcl,
							sizeof(serv_addrcl)) < 0)
				{
					printf("\nConnection Failed \n");
					return -1;
				}
				send(sockcl, hellocl, strlen(hellocl), 0);
				printf("Hello message sent\n");
				valreadcl = read(sockcl, buffercl, 60);
				printf("%s\n", buffercl);
			}

			eraseMark = false;
			// Event handler
			//  SDL_Event e;
			camera = {0, 0, gWindow.getWidth(), gWindow.getHeight()};
			bg = {0, 0, gWindow.getWidth(), gWindow.getHeight()};
			prevposX = 0;
			prevposY = 0;
			curposX = 0;
			curposY = 0;
			// i row,col;
			onYulu1 = false;
			onYulu2 = false;
			int yulutravel;
			int charge = 0;

			professor1.changePos(5940, 1020);
			dog1.changePos(2100, 2190);
			// While application is running
			while (!quit)
			{
				int singlepressPlayer = 0;
				int singlepressYulu = 0;
				frameTime.start();

				// Handle events on queue
				while (SDL_PollEvent(&e) != 0)
				{
					if (play == 1)
					{
						package.handleEvent(e);
						if(isPlayerInside(1500,1270,mapTileSize,mapTileSize*4)){
							buyDrink(e);
							buyFood(e);
						}
						if (isPlayerInside(2850,2940,mapTileSize,mapTileSize))
						{
							cout<<"why"<<endl;
							playGame(e);
	
						}
						if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_RSHIFT)
						{
							if (((curposX >= 1110 && curposX <= 1200) && (curposY >= 390 && curposY <= 660)) || ((curposX >= 540 && curposX <= 840) && (curposY >= 930 && curposY <= 1020)) || ((curposX >= 3690 && curposX <= 3900) && (curposY >= 2280 && curposY <= 2400)) || ((curposX >= 6450 && curposX <= 6540) && (curposY >= 30 && curposY <= 480)) || ((curposX >= 6690 && curposX <= 6780) && (curposY >= 1560 && curposY <= 1680)) || ((curposX >= 1890 && curposX <= 2040) && (curposY >= 2880 && curposY <= 3060)))
							{
								if (!onYulu1)
								{
									yulutravel = 1;
								}
								else
								{
									yulutravel = 0;
								}
								if(playerScore.money>0 && !onYulu1){
									onYulu1=true;
								}
								else if(onYulu1){
									onYulu1=false;
								}
								player1.frame = 4;
								yulu1.frame = 1;
								player1.dir = -1;
								yulu1.dir = -1;
							}
						}
			

							if (!onYulu1)
						{
							if (player1.handleEventSingle(e))
							{
								cout << "handled" << endl;
								singlepressPlayer = 1;
								player1.move(camera.x, camera.y);
							}
							// }

							yulu1.changePos(player1.getPosX()/30*30, player1.getPosY()/30*30);
						}
						else if (onYulu1)
						{
							if (yulu1.handleEventSingle(e))
							{
								cout << "handled" << endl;
								singlepressYulu = 1;
								yulu1.move(camera.x, camera.y);
							}
							player1.changePos(yulu1.getPosX(), yulu1.getPosY());
						}

						quitButton.handle_events(e, 2, 2, 2);
					}
					else if (play == 0)
					{
						back.handle_events(e, 2, 2, 2);
					}
					else if (play == 2)
					{

						helpus1.handle_events(e, 0, 2, 2);
						playButton2.handle_events(e, 1, 2, 2);
						playButton1.handle_events(e, 1, 2, 2);
					}
						else if(play==3)
						{
							//User requests quit
							if( e.type == SDL_KEYDOWN )
							{

								//Select surfaces based on key press
								switch( e.key.keysym.sym )
								{
									case SDLK_SPACE:
									
									if(vert == 0){
										vert_velocity= startVel;
										jumps++;
										j += (600+rand()%800);
										temp.x = j;
										temp.y = verticalloc+205-50;
										temp.h = 50;
										temp.w = 50;
										obstacles.push_back(temp);
									}
									break;
								}
							}

						}
					if (e.type == SDL_QUIT)
					{
						quit = true;
						break;
					}
					// //for handing keys for temp
					// if( e.type == SDL_KEYDOWN &&e.key.keysym.sym == SDLK_RCTRL){
					// 		row = mapElement(curposX,curposY)/xNoSquares;
					// 		col = mapElement(curposX,curposY)%xNoSquares;
					// 		temp[row][col]=0;
					// }
					// else if(e.type==SDL_KEYDOWN &&e.key.keysym.sym == SDLK_LCTRL){
					// 	if(eraseMark==false){
					// 		eraseMark=true;
					// 	}
					// 	else{
					// 		eraseMark= false;
					// 	}
					// }
					//
					// prevposX=curposX;
					// prevposY=curposY;
					// Handle window events
					gWindow.handleEvent(e);
				}

				// Only draw when not minimized
				if (!gWindow.isMinimized())
				{

					if (play == 1)
					{

						package.changePos(pickupX[pickupDestiny], pickupY[pickupDestiny], dropX[pickupDestiny], dropY[pickupDestiny]);

						if (mainchk == 9)
						{
							int *list = new int[7];
							list[0] = player1.getPosX();
							list[1] = player1.getPosY();
							list[2] = player1.frame;
							list[3] = onYulu1;
							list[4] = yulu1.getPosX();
							list[5] = yulu1.getPosY();
							list[6] = yulu1.frame;
							//  list[3] =

							helloserv = datasend(list, 7);

							if (send(new_socketserv, helloserv, strlen(helloserv), 0) >= 0)
							{
							}
							valreadserv = read(new_socketserv, bufferserv, 60);

							int *recvlist1 = new int[7];
							recvlist1 = datarecv(bufferserv, 7);
						

							player2.changePos(recvlist1[0], recvlist1[1]);

							player2.frame = recvlist1[2];
							onYulu2 = recvlist1[3];
							yulu2.changePos(recvlist1[4], recvlist1[5]);
							yulu2.frame = recvlist1[6];
							// 		for (int i = 0; i < 60; i++)
							// {
							// 	/* code */
							// 	bufferserv[i] = 0;
							// }
						}
						if (mainchk == 10)
						{
							int *list = new int[7];
							list[0] = player1.getPosX();
							list[1] = player1.getPosY();
							list[2] = player1.frame;
							list[3] = onYulu1;
							list[4] = yulu1.getPosX();
							list[5] = yulu1.getPosY();
							list[6] = yulu1.frame;

							hellocl = datasend(list, 7);

							send(sockcl, hellocl, strlen(hellocl), 0);

							valreadcl = read(sockcl, buffercl, 60);

							int *recvlist2 = new int[7];
							recvlist2 = datarecv(buffercl, 7);
							char arrt[60] = {};
							
							

							player2.changePos(recvlist2[0], recvlist2[1]);
							cout << recvlist2[2];

							player2.frame = recvlist2[2];
							onYulu2 = recvlist2[3];
							yulu2.changePos(recvlist2[4], recvlist2[5]);
							yulu2.frame = recvlist2[6];
							// for (int i = 0; i < 60; i++)
							// {
							// 	/* code */
							// 	buffercl[i] = 0;
							// }

						}

						if (!onYulu1)
						{
							if (!singlepressPlayer)
							{
								player1.handleEvent();
								player1.move(camera.x, camera.y);
							}
						}
						else if (onYulu1)
						{
							if(yuluMoneyFrame==yuluMoneyFrameLimit-1){
								playerScore.changeMoney(-1);
							}
							yuluMoneyFrame=(yuluMoneyFrame+1)%yuluMoneyFrameLimit;
							if (!singlepressYulu)
							{
								yulu1.handleEvent();
								yulu1.move(camera.x, camera.y);
							}
						}
						if (professorFrame == 4)
						{
							professor1.move();
						}
						professorFrame = (professorFrame + 1) % 5;
						if (DogFrame == 2)
						{
							dog1.move();
						}
						DogFrame = (DogFrame + 1) % 3;

						// prevposX=curposX;
						// prevposY=curposY;
						if (!onYulu1)
						{
							camera.x = (player1.getPosX() + player1.PLAYER_WIDTH / 2) - gWindow.getWidth() / 2;
							camera.y = (player1.getPosY() + player1.PLAYER_HEIGHT / 2) - gWindow.getHeight() / 2;
							camera.w = gWindow.getWidth();
							camera.h = gWindow.getHeight();

							// Keep the camera in bounds
							if (camera.x < 0)
							{
								camera.x = 0;
							}
							if (camera.y < 0)
							{
								camera.y = 0;
							}
							if (camera.x > LEVEL_WIDTH - camera.w)
							{
								camera.x = LEVEL_WIDTH - camera.w;
							}
							if (camera.y > LEVEL_HEIGHT - camera.h)
							{
								camera.y = LEVEL_HEIGHT - camera.h;
							}
						}
						else if (onYulu1)
						{
							camera.x = (yulu1.getPosX() + yulu1.YULU_WIDTH / 2) - gWindow.getWidth() / 2;
							camera.y = (yulu1.getPosY() + yulu1.YULU_HEIGHT / 2) - gWindow.getHeight() / 2;
							camera.w = gWindow.getWidth();
							camera.h = gWindow.getHeight();

							// Keep the camera in bounds
							if (camera.x < 0)
							{
								camera.x = 0;
							}
							if (camera.y < 0)
							{
								camera.y = 0;
							}
							if (camera.x > LEVEL_WIDTH - camera.w)
							{
								camera.x = LEVEL_WIDTH - camera.w;
							}
							if (camera.y > LEVEL_HEIGHT - camera.h)
							{
								camera.y = LEVEL_HEIGHT - camera.h;
							}
						}

						bg = {camera.x / 4, camera.y / 4, camera.w / 4, camera.h / 4};
						quitButton.set(gWindow.getWidth() - gWindow.getWidth() / 10, 0, gWindow.getWidth() / 10, gWindow.getHeight() / 10);
						gBackgroundPlayTexture.loadFromFile("../assets/mapFinal.jpg");
						gBackgroundPlayTexture.set(gWindow.getWidth(), gWindow.getHeight());
						gBackgroundPlayTexture.render(0, 0, &bg);

						// //for marking where temp is set to 1
						curposX = player1.getPosX();
						curposY = player1.getPosY();
						cout << curposX << " " << curposY << endl;
						// row = mapElement(curposX,curposY)/xNoSquares;
						// col = mapElement(curposX,curposY)%xNoSquares;
						// cout<<row<<" "<<col<<endl;
						// if(!eraseMark){
						// temp[row][col]=1;
						// }
						// // isvis[row+1][col]=1;

						// displaying temp
						for (int i = 0; i < 80; i++)
						{
							for (int j = 0; j < 140; j++)
							{
								if (tile[i][j] == 1)
								{
									drawTexture(j * mapTileSize - camera.x, i * mapTileSize - camera.y, mapTileSize, mapTileSize, 0, 0, 0, 100);
								}
							}
						}

						if (!onYulu1)
						{

							SDL_Rect *currentClip1 = &gSpriteClips[player1.frame];
							// SDL_Rect* currentClip2 = &gSpriteClips[player2.frame];
							gSpriteSheetTexture.set(30, 60);
							// if(mainchk == 9){
							player1.set(30, 60);
							// }
							// if(mainchk == 10){						// }
							// gSpriteSheetTexture.render( turtle_specs.x, turtle_specs.y,currentClip );
							drawTexture(player1.getPosX()-camera.x,player1.getPosY()-camera.y+45,30,15,0,255,255,50);
							player1.render(camera.x, camera.y, currentClip1);

						}
						else
						{
							SDL_Rect *currentClip1 = &gYuluClips[yulu1.frame];
							gYuluSheetTexture.set(60, 60);
							yulu1.set(60, 60);

							// gSpriteSheetTexture.render( turtle_specs.x, turtle_specs.y,currentClip );
							drawTexture(yulu1.getPosX()-camera.x,yulu1.getPosY()-camera.y,60,60,0,255,255,50);
							yulu1.render(camera.x, camera.y, currentClip1);
						}
						if (!onYulu2)
						{

							SDL_Rect *currentClip2 = &gSpriteClips[player2.frame];
							// SDL_Rect* currentClip2 = &gSpriteClips[player2.frame];
							gSpriteSheetTexture.set(30, 60);
							// if(mainchk == 9){
							player2.set(30, 60);
							// }
							// if(mainchk == 10){						// }
							// gSpriteSheetTexture.render( turtle_specs.x, turtle_specs.y,currentClip );
							drawTexture(player2.getPosX()-camera.x,player2.getPosY()-camera.y+45,30,15,255,0,0,50);
							player2.render(camera.x, camera.y, currentClip2);
						}
						else
						{
							SDL_Rect *currentClip2 = &gYuluClips[yulu2.frame];
							gYuluSheetTexture.set(60, 60);
							yulu2.set(60, 60);

							// gSpriteSheetTexture.render( turtle_specs.x, turtle_specs.y,currentClip );
							drawTexture(yulu2.getPosX()-camera.x,yulu2.getPosY()-camera.y,60,60,255,0,0,50);
							yulu2.render(camera.x, camera.y, currentClip2);
						}
						// if(!onYulu2){
						// 	SDL_Rect* currentClip2person = &gSpriteClips[player2.frame];
						// 	gSpriteSheetTexture.set(30,60);
						// 	player2.set(30,60);
						// 	player2.render(camera.x,camera.y,currentClip2person);

						// }
						// else{
						// 		yulu2.render(camera.x,camera.y,currentClip2);

						// }

						gProfessorTexture.set(30, 60);
						gDogTexture.set(60, 60);
						professor1.render(camera.x, camera.y);

						SDL_Rect *DogClip = &gDogClips[dog1.frame];
						dog1.render(camera.x, camera.y, DogClip);

						drawTexture(professor1.getPosX() - 3 * mapTileSize - camera.x, professor1.getPosY() - 5 * mapTileSize / 2 - camera.y, (mapTileSize * 13) / 2, mapTileSize * 13 / 2, 255, 255, 255, 50);
						drawTexture(dog1.getPosX() - mapTileSize - camera.x, dog1.getPosY() - mapTileSize - camera.y, mapTileSize * 3, mapTileSize * 3, 255, 255, 255, 50);
						displayDrink(1500,1270,mapTileSize,mapTileSize*4);
						displayFood(1500,1270,mapTileSize,mapTileSize*4);
						displayGame(2850,2940,mapTileSize,mapTileSize);
						// SDL_Color white = {255, 255, 255, 255};
						package.pickup(dropArea[pickupDestiny]);
						package.drop();
						package.render(camera.x, camera.y);
						gYuluStandRectTexture.set(240, 120);
						gYuluStandSqTexture.set(100, 100);
						SDL_Point p = {0, 0};
						SDL_Point *point = &p;

						gYuluStandRectTexture.render(1110 - camera.x, 660 - camera.y, NULL, -90, point);
						gYuluStandRectTexture.set(210, 105);
						gYuluStandRectTexture.render(3705 - camera.x, 2325 - camera.y);
						gYuluStandRectTexture.set(280, 120);
						gYuluStandRectTexture.render(570 - camera.x, 930 - camera.y);
						gYuluStandSqTexture.render(6460 - camera.x, 400 - camera.y);
						gYuluStandSqTexture.render(6700 - camera.x, 1600 - camera.y);
						gYuluStandSqTexture.set(160, 160);
						gYuluStandSqTexture.render(1900 - camera.x, 2920 - camera.y);

						if (((curposX >= 1110 && curposX <= 1200) && (curposY >= 390 && curposY <= 660)) || ((curposX >= 540 && curposX <= 840) && (curposY >= 930 && curposY <= 1020)) || ((curposX >= 3690 && curposX <= 3900) && (curposY >= 2280 && curposY <= 2400)) || ((curposX >= 6450 && curposX <= 6540) && (curposY >= 30 && curposY <= 480)) || ((curposX >= 6690 && curposX <= 6780) && (curposY >= 1560 && curposY <= 1680)) || ((curposX >= 1890 && curposX <= 2040) && (curposY >= 2880 && curposY <= 3060)))
						{
							yuluText.loadFromRenderedText("Press RSHIFT for YULU", white);
							yuluText.render(gWindow.getWidth() / 2 - yuluText.getWidth() / 2, gWindow.getHeight() - yuluText.getHeight() * 4);

							yuluText.loadFromRenderedText("Remember", white);
							yuluText.render(gWindow.getWidth() / 2 - yuluText.getWidth() / 2, gWindow.getHeight() - yuluText.getHeight() * 7);
						}
						playerScore.render();
						quitButton.show();
						bool nishant = CheckCaught();
						if (nishant)
						{
							dogTextTexture.loadFromRenderedText("Ahhhh......", white);
							dogTextTexture.render(gWindow.getWidth() / 2 - yuluText.getWidth() / 2, gWindow.getHeight() - yuluText.getHeight() * 4);
							SDL_RenderPresent(gRenderer);
							SDL_Delay(500);
							onYulu1 = 0;
						}
						else
						{
							SDL_RenderPresent(gRenderer);
						}

						// if(curposX!=prevposX || curposY!= prevposY){
						// 	row = mapElement(curposX,curposY)/xNoSquares;
						// 	col = mapElement(curposX,curposY)%xNoSquares;
						// 	cout<<row<<" "<<col<<endl;
						// 	if(!isvis[row][col]){
						// 	cout<<"bhai input de"<<endl;
						// 	cin>>temp[row][col];
						// 	isvis[row][col]=1;
						// 	}
						// 	prevposX=curposX;
						// 	prevposY=curposY;
						// }
						if(mainchk == 9)
						memset(bufferserv,0,60);
						else
						memset(buffercl,0,60);
					}

					else if (play == 0)
					{
						// help screen

						ghelpsectionbg.set(gWindow.getWidth(), gWindow.getHeight());
						ghelpsectionbg.render(0, 0);

						back.set((gWindow.getWidth() * 90) / 100 - gWindow.getWidth() / 10, (gWindow.getHeight() * 995) / 1000 - gWindow.getHeight() / 10, (gWindow.getWidth() * 30) / 100, (gWindow.getHeight() * 5) / 100);
						back.show();

						SDL_RenderPresent(gRenderer);
					}
					else if (play == 2)
					{
						// start screen

						player1.changePos(60, 30);
						player2.changePos(30, 60);
						yulu1.reset();
						yulu2.reset();
						professor1.reset();
						dog1.reset();
						playerScore.reset();
						// playButton.set( gWindow.getWidth()/2-gWindow.getWidth()/10, gWindow.getHeight()/3-gWindow.getHeight()/10, gWindow.getWidth()/5, gWindow.getHeight()/5 );
						playButton2.set((gWindow.getWidth() * 37) / 100 - gWindow.getWidth() / 10, (gWindow.getHeight() * 69) / 100 - gWindow.getHeight() / 10, gWindow.getWidth() / 2, gWindow.getHeight() / 8);
						playButton1.set((gWindow.getWidth() * 37) / 100 - gWindow.getWidth() / 10, (gWindow.getHeight() * 79) / 100 - gWindow.getHeight() / 10, gWindow.getWidth() / 2, gWindow.getHeight() / 8);
						helpus1.set((gWindow.getWidth() * 90) / 100 - gWindow.getWidth() / 10, (gWindow.getHeight() * 995) / 1000 - gWindow.getHeight() / 10, (gWindow.getWidth() * 30) / 100, (gWindow.getHeight() * 5) / 100);

						SDL_Color textColor = {255, 255, 255, 255};
						string newGame = "New Game";
						string quit = "Quit";
						quitText.loadFromRenderedText(quit, textColor);
						gBackgroundStartScreenTexture.set(gWindow.getWidth(), gWindow.getHeight());
						gBackgroundStartScreenTexture.render(0, 0);

						// playButton.show();
						playButton2.show();
						playButton1.show();
						helpus1.show();

						// Update screen
						SDL_RenderPresent(gRenderer);
					}
					else if(play == 3)
					{
						if (mainchk == 9)
						{
							int *list = new int[7];
							list[0] = player1.getPosX();
							list[1] = player1.getPosY();
							list[2] = player1.frame;
							list[3] = onYulu1;
							list[4] = yulu1.getPosX();
							list[5] = yulu1.getPosY();
							list[6] = yulu1.frame;
							//  list[3] =

							helloserv = datasend(list, 7);

							if (send(new_socketserv, helloserv, strlen(helloserv), 0) >= 0)
							{
							}
							valreadserv = read(new_socketserv, bufferserv, 60);

							int *recvlist1 = new int[7];
							recvlist1 = datarecv(bufferserv, 7);
						

							player2.changePos(recvlist1[0], recvlist1[1]);

							player2.frame = recvlist1[2];
							onYulu2 = recvlist1[3];
							yulu2.changePos(recvlist1[4], recvlist1[5]);
							yulu2.frame = recvlist1[6];
							// 		for (int i = 0; i < 60; i++)
							// {
							// 	/* code */
							// 	bufferserv[i] = 0;
							// }
						}
						if (mainchk == 10)
						{
							int *list = new int[7];
							list[0] = player1.getPosX();
							list[1] = player1.getPosY();
							list[2] = player1.frame;
							list[3] = onYulu1;
							list[4] = yulu1.getPosX();
							list[5] = yulu1.getPosY();
							list[6] = yulu1.frame;

							hellocl = datasend(list, 7);

							send(sockcl, hellocl, strlen(hellocl), 0);

							valreadcl = read(sockcl, buffercl, 60);

							int *recvlist2 = new int[7];
							recvlist2 = datarecv(buffercl, 7);
							char arrt[60] = {};
							
							

							player2.changePos(recvlist2[0], recvlist2[1]);
							cout << recvlist2[2];

							player2.frame = recvlist2[2];
							onYulu2 = recvlist2[3];
							yulu2.changePos(recvlist2[4], recvlist2[5]);
							yulu2.frame = recvlist2[6];
							// for (int i = 0; i < 60; i++)
							// {
							// 	/* code */
							// 	buffercl[i] = 0;
							// }

						}
					gTreeTexture.set(1800,1080);
					//Clear screen
					SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
					SDL_RenderClear( gRenderer );

					//Render current dinoFrame
					
					vert = vert + vert_velocity;
					vert_velocity  = vert_velocity-g ;
					
					if(vert<=0){
						
						vert = 0;
						vert_velocity = 0;
						if(!(jumps%5)){
							speed+=0.5;
							jumps++;
							g+=0.2;
							startVel+=1;
						}
						
					}

					bool flag = 0;    
					bool backflag = 0;
					for(auto &it : backGloc){
						it -= 8*speed;
						gTreeTexture.render(  it,0 );
						
						if(it<=-1800)
							backflag = 1;
					}
					SDL_Rect* currentClipMan = &gBouncingManClips[3- dinoFrame / 4 ];
					gManTexture.render(  10, verticalloc-vert, currentClipMan );
					for(auto &it : obstacles){
						
						it.x -= 8*speed;
						gBoxDinoTexture.render(  it.x,it.y, Box );
						if((it.x<=10+64 && it.x+50>=10+64 && it.y<=verticalloc+205-vert)||(it.x+50>=10 && it.x<=10 && it.y<=verticalloc+205-vert))
							pause = true;
						
						if(it.x<=-50)
							flag = 1;
					}
					
					
					j-=8.0*speed;
					
					
					if(backg1loc<=-1800){
						backg1loc = 0;
						
					}
					if(backflag){
						backGloc.pop_front();
						backGloc.push_back(backGloc[1]+1800);
					}
					
					if(flag){
						dinoCoinGain+=4;
						obstacles.pop_front();

					}
					gCoinTexture.set(60,60);
					gCoinTexture.render(100, 80);
					string s = to_string(dinoCoinGain);
					gMoneyTextTexture.loadFromRenderedText(s, gold);
					float textHeight = 60;
					float textWidth = textHeight * (gMoneyTextTexture.getWidth() / (1.0 * gMoneyTextTexture.getHeight()));
					gMoneyTextTexture.set(textWidth, textHeight);
					gMoneyTextTexture.set(textWidth,textHeight);
					gMoneyTextTexture.render(200,80);
					//Update screen
					SDL_RenderPresent( gRenderer );

					
					//Go to next dinoFrame
					++dinoFrame;

					//Cycle animation
					if( dinoFrame / 4 >= BOUNCING_FRAMES )
					{
						dinoFrame = 0;
					}

				}
				if(pause){
					play =1;
					pause =0;
					playerScore.changeMoney(dinoCoinGain);
					dinoCoinGain=0;
					L = 0;
					obstacles.clear();
					backGloc.clear();
					for(int i = 0;i<3;++i ){
						backGloc.push_back(L);
						L += 1800;
					}
					
					j = 500.0;
					 jumps = 1;
					// speed = 3.0;
					for(int i = 0;i<5;++i ){
						j += (600+rand()%800);
						temp.x = j;
						temp.y = verticalloc+205-50;
						temp.h = 50;
						temp.w = 50;
						obstacles.push_back(temp);

					}
					vert =  0.0,vert_velocity = 0.0;	
				}
					}
					// cout<<play<<endl;
					int time = frameTime.getTicks();
					if (time <= 33)
					{
						SDL_Delay(33 - time);
					}
					cout << frameTime.getTicks() << endl;
					frameTime.stop();
				}
			}
		}
	

	// Free resources and close SDL
	close();

	return 0;
}
